<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>iPod Reader</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f5f5f7;
      font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
    }

    /* --- iPod Body --- */
    .ipod-body {
      width: 232px;
      height: 396px;
      background: linear-gradient(180deg, #ffffff 0%, #f4f4f4 100%);
      border-radius: 28px;
      box-shadow:
        0 1px 0 rgba(255,255,255,0.8) inset,
        0 -1px 0 rgba(0,0,0,0.04) inset,
        0 12px 48px rgba(0,0,0,0.12),
        0 2px 8px rgba(0,0,0,0.08);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px 0 24px;
      position: relative;
      transition: box-shadow 0.3s ease;
      border: 1px solid rgba(0,0,0,0.06);
    }

    .ipod-body.drag-over {
      box-shadow:
        0 1px 0 rgba(255,255,255,0.8) inset,
        0 -1px 0 rgba(0,0,0,0.04) inset,
        0 12px 48px rgba(0,120,255,0.2),
        0 0 0 3px rgba(0,120,255,0.35);
    }

    /* --- Screen --- */
    .ipod-screen {
      width: 186px;
      height: 138px;
      border-radius: 5px;
      box-shadow:
        inset 0 2px 6px rgba(0,0,0,0.25),
        0 1px 0 rgba(255,255,255,0.5);
      overflow: hidden;
      position: relative;
      transition: background 0.4s ease;
    }

    .ipod-screen.theme-light {
      background: linear-gradient(180deg, #a3b8a8 0%, #92a996 100%);
    }
    .ipod-screen.theme-dark {
      background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
    }

    /* LCD scanline overlay */
    .ipod-screen::after {
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(
        0deg, transparent, transparent 2px,
        rgba(0,0,0,0.03) 2px, rgba(0,0,0,0.03) 4px
      );
      pointer-events: none;
      border-radius: 5px;
      z-index: 5;
    }

    /* --- Screen viewport for slide transitions --- */
    .screen-viewport {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
    }

    /* --- Screen views --- */
    .screen-view {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      transition: transform 0.3s cubic-bezier(0.25, 0.1, 0.25, 1), opacity 0.3s ease;
      will-change: transform;
    }

    .screen-view.pos-center { transform: translateX(0); opacity: 1; }
    .screen-view.pos-left { transform: translateX(-100%); opacity: 0; pointer-events: none; }
    .screen-view.pos-right { transform: translateX(100%); opacity: 0; pointer-events: none; }
    .screen-view.pos-hidden { transform: translateX(100%); opacity: 0; pointer-events: none; }

    /* No transition for instant positioning */
    .screen-view.no-transition { transition: none !important; }

    /* --- Boot screen --- */
    .boot-screen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      transition: opacity 0.6s ease;
    }
    .theme-light .boot-screen { background: linear-gradient(180deg, #a3b8a8 0%, #92a996 100%); }
    .theme-dark .boot-screen { background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%); }

    .boot-logo {
      opacity: 0;
      transform: scale(0.8);
      transition: opacity 0.8s ease, transform 0.8s ease;
    }
    .boot-logo.visible {
      opacity: 1;
      transform: scale(1);
    }
    .boot-logo svg { width: 48px; height: 48px; }
    .theme-light .boot-logo svg { fill: #2c4a30; }
    .theme-dark .boot-logo svg { fill: #8ebbff; }

    /* --- Title bar --- */
    .title-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px 8px 3px;
      font-size: 10px;
      font-weight: 700;
      border-bottom: 1px solid rgba(0,0,0,0.1);
      flex-shrink: 0;
    }
    .theme-light .title-bar { color: #2c4a30; border-color: rgba(0,0,0,0.1); }
    .theme-dark .title-bar { color: #8ebbff; border-color: rgba(255,255,255,0.1); }
    .title-bar-text { letter-spacing: 0.03em; }
    .title-bar-right { font-weight: 500; font-size: 9px; opacity: 0.7; }

    /* --- Menu --- */
    .menu-list {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .menu-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 5px 8px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      flex-shrink: 0;
    }
    .theme-light .menu-item { color: #1a2e1a; }
    .theme-dark .menu-item { color: #d0d8e8; }
    .menu-item.selected { border-radius: 2px; }
    .theme-light .menu-item.selected { background: #2c4a30; color: #fff; }
    .theme-dark .menu-item.selected { background: #4a7dff; color: #fff; }
    .menu-item-arrow { font-size: 10px; opacity: 0.5; }
    .menu-item.selected .menu-item-arrow { opacity: 0.9; }
    .menu-item-icon { margin-right: 6px; font-size: 11px; width: 16px; text-align: center; }
    .menu-item-label { flex: 1; }

    /* --- Now Playing --- */
    .np-header {
      display: flex;
      justify-content: space-between;
      padding: 5px 8px 2px;
      font-size: 10px;
      font-weight: 600;
      flex-shrink: 0;
    }
    .theme-light .np-header { color: #2c4a30; }
    .theme-dark .np-header { color: #8ebbff; }

    .np-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 0 10px;
      min-height: 0;
      position: relative;
    }

    .np-word {
      font-size: 26px;
      font-weight: 700;
      text-align: center;
      line-height: 1.15;
      letter-spacing: -0.01em;
      word-break: break-all;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .theme-light .np-word { color: #1a2e1a; }
    .theme-dark .np-word { color: #e8eeff; }
    .np-word.long { font-size: 20px; }
    .np-word.xlong { font-size: 15px; }

    .np-subtitle {
      font-size: 11px;
      font-weight: 500;
      margin-top: 4px;
      text-align: center;
      transition: opacity 0.3s ease;
    }
    .theme-light .np-subtitle { color: #3a5c3e; }
    .theme-dark .np-subtitle { color: #7a9ac0; }

    .eq-container {
      display: flex;
      align-items: flex-end;
      gap: 2px;
      height: 18px;
      margin-top: 4px;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .eq-container.active { opacity: 1; }

    .eq-bar {
      width: 4px;
      border-radius: 1px;
      transition: height 0.1s ease;
    }
    .theme-light .eq-bar { background: #2c4a30; }
    .theme-dark .eq-bar { background: #4a7dff; }

    .np-progress {
      height: 3px;
      background: rgba(0,0,0,0.1);
      margin: 0 8px 5px;
      border-radius: 2px;
      overflow: hidden;
      flex-shrink: 0;
    }
    .theme-dark .np-progress { background: rgba(255,255,255,0.1); }

    .np-progress-fill {
      height: 100%;
      width: 0%;
      border-radius: 2px;
      transition: width 0.1s linear;
    }
    .theme-light .np-progress-fill { background: #2c4a30; }
    .theme-dark .np-progress-fill { background: #4a7dff; }

    .np-chapter {
      font-size: 9px;
      font-weight: 500;
      padding: 0 8px 2px;
      text-align: center;
      flex-shrink: 0;
      opacity: 0.6;
    }
    .theme-light .np-chapter { color: #2c4a30; }
    .theme-dark .np-chapter { color: #7a9ac0; }

    /* --- Settings --- */
    .settings-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 5px 8px;
      font-size: 11px;
      font-weight: 500;
      flex-shrink: 0;
    }
    .theme-light .settings-item { color: #1a2e1a; }
    .theme-dark .settings-item { color: #d0d8e8; }
    .settings-item.selected { border-radius: 2px; }
    .theme-light .settings-item.selected { background: #2c4a30; color: #fff; }
    .theme-dark .settings-item.selected { background: #4a7dff; color: #fff; }
    .settings-value { font-size: 10px; opacity: 0.7; }
    .settings-item.selected .settings-value { opacity: 1; }

    /* --- Library / Chapters --- */
    .library-empty {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      opacity: 0.5;
    }
    .theme-light .library-empty { color: #2c4a30; }
    .theme-dark .library-empty { color: #7a9ac0; }

    .chapter-item {
      display: flex;
      align-items: center;
      padding: 5px 8px;
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
      flex-shrink: 0;
    }
    .theme-light .chapter-item { color: #1a2e1a; }
    .theme-dark .chapter-item { color: #d0d8e8; }
    .chapter-item.selected { border-radius: 2px; }
    .theme-light .chapter-item.selected { background: #2c4a30; color: #fff; }
    .theme-dark .chapter-item.selected { background: #4a7dff; color: #fff; }
    .chapter-num { font-size: 9px; opacity: 0.5; margin-right: 6px; width: 16px; text-align: right; }
    .chapter-item.selected .chapter-num { opacity: 0.8; }

    /* --- Click Wheel --- */
    .click-wheel {
      width: 168px;
      height: 168px;
      border-radius: 50%;
      background: radial-gradient(circle at 45% 40%, #f0f0f0, #d4d4d4);
      box-shadow:
        inset 0 1px 4px rgba(0,0,0,0.12),
        0 1px 2px rgba(255,255,255,0.6);
      position: relative;
      margin-top: 20px;
      cursor: grab;
    }
    .click-wheel:active { cursor: grabbing; }

    .wheel-btn {
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #555;
      font-weight: 600;
      cursor: pointer;
      z-index: 2;
      transition: opacity 0.1s, transform 0.1s;
    }
    .wheel-btn:active { transform: scale(0.92); opacity: 0.5; }

    .wheel-menu { top: 8px; left: 50%; transform: translateX(-50%); font-size: 11px; letter-spacing: 0.06em; width: 60px; height: 30px; }
    .wheel-forward { right: 6px; top: 50%; transform: translateY(-50%); font-size: 14px; width: 34px; height: 50px; }
    .wheel-playpause { bottom: 8px; left: 50%; transform: translateX(-50%); font-size: 14px; width: 60px; height: 30px; }
    .wheel-back { left: 6px; top: 50%; transform: translateY(-50%); font-size: 14px; width: 34px; height: 50px; }

    .wheel-back:active, .wheel-forward:active { transform: translateY(-50%) scale(0.92); opacity: 0.5; }
    .wheel-menu:active { transform: translateX(-50%) scale(0.92); opacity: 0.5; }
    .wheel-playpause:active { transform: translateX(-50%) scale(0.92); opacity: 0.5; }

    .wheel-center {
      position: absolute;
      width: 60px; height: 60px;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background: linear-gradient(180deg, #f8f8f8, #e6e6e6);
      box-shadow: 0 1px 3px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.8);
      cursor: pointer;
      z-index: 3;
      transition: transform 0.1s, box-shadow 0.1s;
    }
    .wheel-center:active { transform: translate(-50%, -50%) scale(0.95); box-shadow: 0 0px 2px rgba(0,0,0,0.12); }

    #pdfInput { display: none; }
  </style>
</head>
<body>

  <div class="ipod-body" id="ipodBody">
    <div class="ipod-screen theme-light" id="screen">

      <!-- Boot screen -->
      <div class="boot-screen" id="bootScreen">
        <div class="boot-logo" id="bootLogo">
          <svg viewBox="0 0 48 48"><path d="M31.2 8.6c1.6-2 2.7-4.7 2.4-7.4-2.3.1-5.1 1.5-6.7 3.5-1.5 1.7-2.8 4.5-2.4 7.1 2.5.2 5.1-1.3 6.7-3.2zM33.6 12c-3.7-.2-6.9 2.1-8.7 2.1-1.8 0-4.5-2-7.4-1.9-3.8.1-7.3 2.2-9.3 5.6-4 6.9-1 17.1 2.8 22.7 1.9 2.8 4.2 5.8 7.2 5.7 2.9-.1 3.9-1.9 7.4-1.9 3.4 0 4.4 1.9 7.4 1.8 3.1-.1 5-2.8 6.9-5.6 2.2-3.2 3-6.3 3.1-6.4-.1 0-5.9-2.3-6-9.1 0-5.7 4.6-8.4 4.9-8.6-2.7-4-6.9-4.4-8.3-4.4z"/></svg>
        </div>
      </div>

      <!-- Screen viewport for slide transitions -->
      <div class="screen-viewport" id="viewport">

        <div class="screen-view pos-center" id="viewMenu">
          <div class="title-bar">
            <span class="title-bar-text">iPod Reader</span>
            <span class="title-bar-right">&#9654;</span>
          </div>
          <div class="menu-list" id="menuList"></div>
        </div>

        <div class="screen-view pos-hidden" id="viewNowPlaying">
          <div class="np-header">
            <span id="npWpm">250 WPM</span>
            <span id="npCount"></span>
          </div>
          <div class="np-chapter" id="npChapter"></div>
          <div class="np-content">
            <div class="np-word" id="npWord">iPod Reader</div>
            <div class="np-subtitle" id="npSubtitle">Drop a PDF to begin</div>
            <div class="eq-container" id="eqContainer"></div>
          </div>
          <div class="np-progress">
            <div class="np-progress-fill" id="npProgressFill"></div>
          </div>
        </div>

        <div class="screen-view pos-hidden" id="viewLibrary">
          <div class="title-bar">
            <span class="title-bar-text">Library</span>
            <span class="title-bar-right" id="libCount"></span>
          </div>
          <div class="menu-list" id="libraryList"></div>
        </div>

        <div class="screen-view pos-hidden" id="viewChapters">
          <div class="title-bar">
            <span class="title-bar-text">Chapters</span>
            <span class="title-bar-right" id="chapCount"></span>
          </div>
          <div class="menu-list" id="chaptersList"></div>
        </div>

        <div class="screen-view pos-hidden" id="viewSettings">
          <div class="title-bar">
            <span class="title-bar-text">Settings</span>
          </div>
          <div class="menu-list" id="settingsList"></div>
        </div>

      </div>
    </div>

    <div class="click-wheel" id="clickWheel">
      <div class="wheel-btn wheel-menu" id="btnMenu">MENU</div>
      <div class="wheel-btn wheel-forward" id="btnForward">&#9654;&#9654;&#124;</div>
      <div class="wheel-btn wheel-playpause" id="btnPlayPause">&#9654;&#10074;&#10074;</div>
      <div class="wheel-btn wheel-back" id="btnBack">&#124;&#9664;&#9664;</div>
      <div class="wheel-center" id="btnCenter"></div>
    </div>
  </div>

  <input type="file" id="pdfInput" accept=".pdf">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    // --- Config ---
    const DEFAULT_WPM = 250;
    const MIN_WPM = 50;
    const MAX_WPM = 1000;
    const WPM_STEP = 25;
    const TTS_CHUNK_SIZE = 15;
    const EQ_BAR_COUNT = 12;
    const STORAGE_KEY = 'ipod-reader';

    // --- State ---
    let words = [];
    let currentIndex = 0;
    let wpm = DEFAULT_WPM;
    let isPlaying = false;
    let intervalId = null;
    let pdfFileName = '';
    let chapters = [];
    let bookmarks = {};
    let library = [];
    let booted = false;

    let settings = {
      theme: 'light',
      ttsEnabled: true,
      defaultWpm: 250,
      voice: null
    };

    // TTS
    let ttsVoice = null;
    let ttsSpeaking = false;
    let nextTTSChunkAt = 0;
    let ttsBoundaryIndex = 0;  // word index driven by TTS boundary events
    let ttsDriven = false;     // true when TTS boundary is actively driving display

    // EQ
    let eqAnimId = null;

    // Navigation
    let viewStack = ['menu'];
    let activeViewName = 'menu';
    let menuSelections = {};

    // Audio context for click sounds
    let audioCtx = null;

    // --- DOM ---
    const ipodBody = document.getElementById('ipodBody');
    const screenEl = document.getElementById('screen');
    const viewport = document.getElementById('viewport');
    const clickWheel = document.getElementById('clickWheel');
    const btnMenu = document.getElementById('btnMenu');
    const btnForward = document.getElementById('btnForward');
    const btnPlayPause = document.getElementById('btnPlayPause');
    const btnBack = document.getElementById('btnBack');
    const btnCenter = document.getElementById('btnCenter');
    const pdfInput = document.getElementById('pdfInput');
    const bootScreen = document.getElementById('bootScreen');
    const bootLogo = document.getElementById('bootLogo');

    const npWpm = document.getElementById('npWpm');
    const npCount = document.getElementById('npCount');
    const npWord = document.getElementById('npWord');
    const npSubtitle = document.getElementById('npSubtitle');
    const npProgressFill = document.getElementById('npProgressFill');
    const npChapter = document.getElementById('npChapter');
    const eqContainer = document.getElementById('eqContainer');

    // --- PDF.js Setup ---
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    // =========================================================
    //  CLICK SOUND (Web Audio API)
    // =========================================================
    function initAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }

    function playClick() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);

      osc.type = 'sine';
      osc.frequency.setValueAtTime(1200, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.03);

      gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.04);

      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.04);
    }

    function playSelectSound() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);

      osc.type = 'sine';
      osc.frequency.setValueAtTime(900, audioCtx.currentTime);
      osc.frequency.setValueAtTime(1100, audioCtx.currentTime + 0.04);

      gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.08);

      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.08);
    }

    // Ensure audio context is initialized on first user interaction
    function ensureAudio() {
      initAudio();
      if (audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    }

    // =========================================================
    //  BOOT ANIMATION
    // =========================================================
    function runBootSequence() {
      // Show Apple logo
      setTimeout(() => { bootLogo.classList.add('visible'); }, 200);

      // Fade out boot screen, reveal menu
      setTimeout(() => {
        bootScreen.style.opacity = '0';
        setTimeout(() => {
          bootScreen.style.display = 'none';
          booted = true;
        }, 600);
      }, 1800);
    }

    // =========================================================
    //  PERSISTENCE
    // =========================================================
    function loadSettings() {
      try {
        const data = JSON.parse(localStorage.getItem(STORAGE_KEY));
        if (data) {
          if (data.settings) Object.assign(settings, data.settings);
          if (data.bookmarks) bookmarks = data.bookmarks;
          if (data.library) library = data.library;
        }
      } catch (e) {}
      wpm = settings.defaultWpm;
      applyTheme();
    }

    function saveSettings() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify({ settings, bookmarks, library }));
      } catch (e) {}
    }

    function applyTheme() {
      screenEl.classList.remove('theme-light', 'theme-dark');
      screenEl.classList.add(`theme-${settings.theme}`);
    }

    // =========================================================
    //  TTS (with boundary-driven sync)
    // =========================================================
    function setupTTS() {
      function pickVoice() {
        const voices = speechSynthesis.getVoices();
        if (settings.voice) {
          const saved = voices.find(v => v.name === settings.voice);
          if (saved) { ttsVoice = saved; return; }
        }
        // Prefer premium/enhanced voices (much more natural sounding)
        // macOS has "Premium" and "Enhanced" variants that sound great
        const preferredNames = [
          'Ava (Premium)', 'Zoe (Premium)', 'Samantha (Enhanced)',
          'Ava', 'Zoe', 'Samantha',
          'Karen (Enhanced)', 'Karen',
          'Daniel (Enhanced)', 'Daniel',
        ];
        for (const name of preferredNames) {
          const match = voices.find(v => v.name === name);
          if (match) { ttsVoice = match; return; }
        }
        // Fallback: any local English voice
        ttsVoice = voices.find(v => v.lang.startsWith('en') && v.localService) ||
                   voices.find(v => v.lang.startsWith('en')) ||
                   voices[0] || null;
      }
      pickVoice();
      speechSynthesis.addEventListener('voiceschanged', pickVoice);
    }

    function speakChunk(startIdx, count) {
      if (!settings.ttsEnabled || !ttsVoice) return;
      speechSynthesis.cancel();

      const end = Math.min(startIdx + count, words.length);
      const phrase = words.slice(startIdx, end).join(' ');
      const utter = new SpeechSynthesisUtterance(phrase);
      utter.voice = ttsVoice;
      // Slightly slower rate feels more natural; cap at 2.5 to avoid garbling
      utter.rate = Math.max(0.5, Math.min(2.5, wpm / 300));
      utter.pitch = 1;
      utter.volume = 1;
      ttsSpeaking = true;

      // Track which word in the chunk we're on
      let chunkWordIndex = 0;
      ttsBoundaryIndex = startIdx;
      ttsDriven = true;

      utter.onboundary = (event) => {
        if (event.name === 'word' && isPlaying) {
          // Map character offset to word index in chunk
          const textSoFar = phrase.substring(0, event.charIndex);
          const wordsSoFar = textSoFar.split(/\s+/).filter(w => w.length > 0).length;
          const globalIdx = startIdx + wordsSoFar;

          if (globalIdx < words.length && globalIdx >= startIdx) {
            displayWord(words[globalIdx]);
            currentIndex = globalIdx + 1;
            updateNowPlaying();
          }
        }
      };

      utter.onend = () => {
        ttsSpeaking = false;
        ttsDriven = false;
        // If still playing and more words to go, schedule next chunk
        if (isPlaying && currentIndex < words.length) {
          nextTTSChunkAt = currentIndex;
          speakChunk(currentIndex, TTS_CHUNK_SIZE);
          nextTTSChunkAt = currentIndex + TTS_CHUNK_SIZE;
        } else if (isPlaying && currentIndex >= words.length) {
          stopReading();
          npWord.textContent = 'Done';
          npSubtitle.textContent = `${words.length.toLocaleString()} words`;
          npSubtitle.style.opacity = '1';
          saveBookmark();
        }
      };

      utter.onerror = () => { ttsSpeaking = false; ttsDriven = false; };
      speechSynthesis.speak(utter);
    }

    function stopTTS() {
      speechSynthesis.cancel();
      ttsSpeaking = false;
      ttsDriven = false;
    }

    // =========================================================
    //  EQ VISUALIZER
    // =========================================================
    function setupEQ() {
      eqContainer.innerHTML = '';
      for (let i = 0; i < EQ_BAR_COUNT; i++) {
        const bar = document.createElement('div');
        bar.className = 'eq-bar';
        bar.style.height = '2px';
        eqContainer.appendChild(bar);
      }
    }

    function startEQ() {
      eqContainer.classList.add('active');
      function animate() {
        const bars = eqContainer.children;
        for (let i = 0; i < bars.length; i++) {
          const h = isPlaying ? (Math.random() * 14 + 2) : 2;
          bars[i].style.height = h + 'px';
        }
        eqAnimId = requestAnimationFrame(animate);
      }
      animate();
    }

    function stopEQ() {
      if (eqAnimId) cancelAnimationFrame(eqAnimId);
      eqAnimId = null;
      const bars = eqContainer.children;
      for (let i = 0; i < bars.length; i++) bars[i].style.height = '2px';
      if (words.length === 0) eqContainer.classList.remove('active');
    }

    // =========================================================
    //  PDF EXTRACTION
    // =========================================================
    async function extractTextFromPDF(arrayBuffer) {
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      let fullText = '';
      for (let i = 1; i <= pdf.numPages; i++) {
        npSubtitle.textContent = `Loading page ${i} / ${pdf.numPages}`;
        const page = await pdf.getPage(i);
        const content = await page.getTextContent();
        const pageText = content.items.map(item => item.str).join(' ');
        fullText += pageText + ' ';
      }
      return fullText.split(/\s+/).filter(w => w.length > 0);
    }

    // =========================================================
    //  CHAPTERS
    // =========================================================
    function detectChapters(wordArray) {
      const chaps = [{ title: 'Start', wordIndex: 0 }];
      const patterns = [
        /\b(Chapter|CHAPTER)\s+(\d+|[IVXLC]+)\b/gi,
        /\b(Part|PART)\s+(\d+|[IVXLC]+)\b/gi,
        /\b(Section|SECTION)\s+(\d+)\b/gi,
      ];
      for (let i = 0; i < wordArray.length; i++) {
        const remaining = wordArray.slice(i, i + 4).join(' ');
        for (const pat of patterns) {
          pat.lastIndex = 0;
          const match = pat.exec(remaining);
          if (match && remaining.indexOf(match[0]) === 0) {
            chaps.push({ title: match[0], wordIndex: i });
            break;
          }
        }
      }
      return chaps;
    }

    function getCurrentChapter() {
      if (chapters.length <= 1) return null;
      let current = chapters[0];
      for (let i = 1; i < chapters.length; i++) {
        if (chapters[i].wordIndex <= currentIndex) current = chapters[i];
        else break;
      }
      return current;
    }

    function getCurrentChapterIndex() {
      let idx = 0;
      for (let i = 1; i < chapters.length; i++) {
        if (chapters[i].wordIndex <= currentIndex) idx = i;
        else break;
      }
      return idx;
    }

    // =========================================================
    //  SENTENCE-AWARE PACING
    // =========================================================
    function getWordDelay(word) {
      const base = 60000 / wpm;
      if (/[.!?]$/.test(word)) return base * 2.2;
      if (/[,;:]$/.test(word)) return base * 1.5;
      if (/[—–…]$/.test(word)) return base * 1.8;
      return base;
    }

    // =========================================================
    //  RSVP ENGINE
    // =========================================================
    function startReading() {
      if (words.length === 0) return;
      isPlaying = true;
      slideToView('nowPlaying', 'forward');
      startEQ();

      if (settings.ttsEnabled && ttsVoice) {
        // TTS-driven mode: speech boundary events drive the display
        nextTTSChunkAt = currentIndex;
        speakChunk(currentIndex, TTS_CHUNK_SIZE);
        nextTTSChunkAt = currentIndex + TTS_CHUNK_SIZE;

        // Fallback timer in case onboundary doesn't fire (some browsers)
        startFallbackTimer();
      } else {
        // Timer-driven mode (no TTS)
        scheduleNextWord();
      }
    }

    // Fallback: if TTS is on but onboundary events aren't firing,
    // we still advance visually after a timeout
    let fallbackTimerId = null;
    let lastBoundaryTime = 0;

    function startFallbackTimer() {
      lastBoundaryTime = Date.now();
      clearInterval(fallbackTimerId);
      fallbackTimerId = setInterval(() => {
        if (!isPlaying) { clearInterval(fallbackTimerId); return; }
        // If no boundary event for 2 seconds, fall back to timer-driven
        if (Date.now() - lastBoundaryTime > 2000 && ttsDriven) {
          ttsDriven = false;
          scheduleNextWord();
        }
      }, 500);
    }

    function scheduleNextWord() {
      if (!isPlaying || ttsDriven) return;
      if (currentIndex >= words.length) {
        stopReading();
        npWord.textContent = 'Done';
        npSubtitle.textContent = `${words.length.toLocaleString()} words`;
        npSubtitle.style.opacity = '1';
        saveBookmark();
        return;
      }

      // TTS chunk boundary (non-sync mode)
      if (settings.ttsEnabled && currentIndex >= nextTTSChunkAt) {
        speakChunk(currentIndex, TTS_CHUNK_SIZE);
        nextTTSChunkAt = currentIndex + TTS_CHUNK_SIZE;
      }

      displayWord(words[currentIndex]);
      const delay = getWordDelay(words[currentIndex]);
      currentIndex++;
      updateNowPlaying();
      intervalId = setTimeout(scheduleNextWord, delay);
    }

    function stopReading() {
      isPlaying = false;
      clearTimeout(intervalId);
      clearInterval(fallbackTimerId);
      intervalId = null;
      stopTTS();
      stopEQ();
      saveBookmark();
      if (words.length > 0) {
        npSubtitle.textContent = 'paused';
        npSubtitle.style.opacity = '0.7';
      }
    }

    function togglePlayPause() {
      if (words.length === 0) return;
      if (currentIndex >= words.length && !isPlaying) currentIndex = 0;
      if (isPlaying) stopReading(); else startReading();
    }

    function skipForward() {
      if (words.length === 0) return;
      if (currentIndex < words.length) {
        displayWord(words[currentIndex]);
        currentIndex = Math.min(currentIndex + 1, words.length);
        updateNowPlaying();
      }
    }

    function skipBack() {
      if (words.length === 0) return;
      currentIndex = Math.max(currentIndex - 2, 0);
      displayWord(words[currentIndex]);
      currentIndex++;
      updateNowPlaying();
    }

    function skipToChapter(chapterIndex) {
      if (chapterIndex < 0 || chapterIndex >= chapters.length) return;
      const wasPlaying = isPlaying;
      if (isPlaying) stopReading();
      currentIndex = chapters[chapterIndex].wordIndex;
      displayWord(words[currentIndex]);
      updateNowPlaying();
      if (wasPlaying) startReading();
    }

    function adjustSpeed(delta) {
      wpm = Math.max(MIN_WPM, Math.min(MAX_WPM, wpm + delta));
      npWpm.textContent = `${wpm} WPM`;
    }

    function displayWord(word) {
      npWord.textContent = word;
      npWord.classList.remove('long', 'xlong');
      if (word.length > 14) npWord.classList.add('xlong');
      else if (word.length > 9) npWord.classList.add('long');
      // Update last boundary time for fallback check
      lastBoundaryTime = Date.now();
    }

    function updateNowPlaying() {
      const pct = words.length > 0 ? (currentIndex / words.length) * 100 : 0;
      npProgressFill.style.width = `${pct}%`;
      npCount.textContent = `${currentIndex.toLocaleString()} / ${words.length.toLocaleString()}`;
      npWpm.textContent = `${wpm} WPM`;
      const chap = getCurrentChapter();
      npChapter.textContent = chap && chapters.length > 1 ? chap.title : '';
    }

    // =========================================================
    //  BOOKMARKS & LIBRARY
    // =========================================================
    function saveBookmark() {
      if (pdfFileName && words.length > 0 && currentIndex > 0) {
        bookmarks[pdfFileName] = currentIndex;
        saveSettings();
      }
    }

    function loadBookmark() {
      if (pdfFileName && bookmarks[pdfFileName]) {
        currentIndex = Math.min(bookmarks[pdfFileName], words.length);
      }
    }

    function addToLibrary(name, wordCount) {
      const existing = library.find(l => l.name === name);
      if (existing) { existing.wordCount = wordCount; existing.date = Date.now(); }
      else library.push({ name, wordCount, date: Date.now() });
      library.sort((a, b) => b.date - a.date);
      if (library.length > 20) library.length = 20;
      saveSettings();
    }

    // =========================================================
    //  PDF LOADING
    // =========================================================
    function setupDragAndDrop() {
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(evt => {
        document.body.addEventListener(evt, e => { e.preventDefault(); e.stopPropagation(); });
      });
      ipodBody.addEventListener('dragenter', () => ipodBody.classList.add('drag-over'));
      ipodBody.addEventListener('dragover', e => { e.preventDefault(); ipodBody.classList.add('drag-over'); });
      ipodBody.addEventListener('dragleave', e => {
        if (!ipodBody.contains(e.relatedTarget)) ipodBody.classList.remove('drag-over');
      });
      ipodBody.addEventListener('drop', async e => {
        e.preventDefault();
        ipodBody.classList.remove('drag-over');
        const file = e.dataTransfer.files[0];
        if (file) await loadPDF(file);
      });
      pdfInput.addEventListener('change', async () => {
        const file = pdfInput.files[0];
        if (file) await loadPDF(file);
        pdfInput.value = '';
      });
    }

    async function loadPDF(file) {
      if (file.type !== 'application/pdf' && !file.name.endsWith('.pdf')) {
        npWord.textContent = 'Not a PDF';
        npSubtitle.textContent = 'Drop a PDF file';
        slideToView('nowPlaying', 'forward');
        return;
      }
      if (isPlaying) stopReading();
      pdfFileName = file.name.replace(/\.pdf$/i, '');
      slideToView('nowPlaying', 'forward');
      npWord.textContent = 'Loading...';
      npSubtitle.textContent = file.name;
      npSubtitle.style.opacity = '1';

      try {
        const arrayBuffer = await file.arrayBuffer();
        words = await extractTextFromPDF(arrayBuffer);
        currentIndex = 0;
        if (words.length === 0) { npWord.textContent = 'No text'; npSubtitle.textContent = 'PDF appears empty'; return; }
        chapters = detectChapters(words);
        addToLibrary(pdfFileName, words.length);
        loadBookmark();
        npWord.textContent = truncate(pdfFileName, 16);
        npSubtitle.textContent = `${words.length.toLocaleString()} words`;
        npSubtitle.style.opacity = '1';
        eqContainer.classList.add('active');
        updateNowPlaying();
      } catch (err) {
        npWord.textContent = 'Error';
        npSubtitle.textContent = 'Could not read PDF';
        console.error(err);
      }
    }

    function truncate(str, max) {
      return str.length > max ? str.slice(0, max - 1) + '\u2026' : str;
    }

    // =========================================================
    //  VIEW / NAVIGATION with SLIDE TRANSITIONS
    // =========================================================
    const viewNames = ['menu', 'nowPlaying', 'library', 'chapters', 'settings'];

    function getViewEl(name) {
      return document.getElementById('view' + name.charAt(0).toUpperCase() + name.slice(1));
    }

    function slideToView(viewName, direction) {
      if (activeViewName === viewName) return;

      const oldEl = getViewEl(activeViewName);
      const newEl = getViewEl(viewName);
      if (!oldEl || !newEl) return;

      // Position new view offscreen on correct side (instant, no transition)
      newEl.classList.add('no-transition');
      if (direction === 'forward') {
        newEl.classList.remove('pos-center', 'pos-left', 'pos-hidden');
        newEl.classList.add('pos-right');
      } else {
        newEl.classList.remove('pos-center', 'pos-right', 'pos-hidden');
        newEl.classList.add('pos-left');
      }

      // Force reflow
      newEl.offsetHeight;

      // Remove no-transition and animate both
      newEl.classList.remove('no-transition');

      // Slide old out, new in
      oldEl.classList.remove('pos-center');
      oldEl.classList.add(direction === 'forward' ? 'pos-left' : 'pos-right');

      newEl.classList.remove('pos-left', 'pos-right', 'pos-hidden');
      newEl.classList.add('pos-center');

      activeViewName = viewName;

      // Rebuild view content
      if (viewName === 'menu') buildMainMenu();
      if (viewName === 'library') buildLibraryView();
      if (viewName === 'chapters') buildChaptersView();
      if (viewName === 'settings') buildSettingsView();
    }

    function navigateTo(viewName) {
      if (viewStack[viewStack.length - 1] !== viewName) {
        viewStack.push(viewName);
      }
      slideToView(viewName, 'forward');
    }

    function goBack() {
      playClick();
      if (viewStack.length > 1) {
        viewStack.pop();
        const prev = viewStack[viewStack.length - 1];
        slideToView(prev, 'back');
      }
    }

    function currentView() {
      return activeViewName;
    }

    // =========================================================
    //  MENU BUILDERS
    // =========================================================
    function buildMainMenu() {
      const list = document.getElementById('menuList');
      const items = [
        { icon: '&#9654;', label: 'Now Playing', action: 'nowPlaying', hasArrow: true },
        { icon: '&#9776;', label: 'Library', action: 'library', hasArrow: true },
        { icon: '&#167;', label: 'Chapters', action: 'chapters', hasArrow: true },
        { icon: '&#9881;', label: 'Settings', action: 'settings', hasArrow: true },
        { icon: '&#43;', label: 'Add PDF...', action: 'addPdf', hasArrow: false },
      ];
      list.innerHTML = '';
      const sel = menuSelections['menu'] || 0;
      items.forEach((item, i) => {
        const el = document.createElement('div');
        el.className = 'menu-item' + (i === sel ? ' selected' : '');
        el.innerHTML = `<span class="menu-item-icon">${item.icon}</span><span class="menu-item-label">${item.label}</span>${item.hasArrow ? '<span class="menu-item-arrow">&#9654;</span>' : ''}`;
        el.dataset.action = item.action;
        el.dataset.index = i;
        list.appendChild(el);
      });
    }

    function buildLibraryView() {
      const list = document.getElementById('libraryList');
      const countEl = document.getElementById('libCount');
      list.innerHTML = '';
      if (library.length === 0) { list.innerHTML = '<div class="library-empty">No PDFs yet</div>'; countEl.textContent = ''; return; }
      countEl.textContent = `${library.length} items`;
      const sel = menuSelections['library'] || 0;
      library.forEach((item, i) => {
        const el = document.createElement('div');
        el.className = 'menu-item' + (i === sel ? ' selected' : '');
        const bm = bookmarks[item.name];
        const progress = bm ? Math.round((bm / item.wordCount) * 100) + '%' : '';
        el.innerHTML = `<span class="menu-item-label">${truncate(item.name, 18)}</span><span class="menu-item-arrow" style="font-size:9px;opacity:0.5">${progress}</span>`;
        el.dataset.index = i;
        list.appendChild(el);
      });
    }

    function buildChaptersView() {
      const list = document.getElementById('chaptersList');
      const countEl = document.getElementById('chapCount');
      list.innerHTML = '';
      if (chapters.length <= 1) { list.innerHTML = '<div class="library-empty">No chapters found</div>'; countEl.textContent = ''; return; }
      countEl.textContent = `${chapters.length} chapters`;
      const sel = menuSelections['chapters'] || 0;
      const curChapIdx = getCurrentChapterIndex();
      chapters.forEach((chap, i) => {
        const el = document.createElement('div');
        el.className = 'chapter-item' + (i === sel ? ' selected' : '');
        const playing = (i === curChapIdx && words.length > 0) ? ' &#9654;' : '';
        el.innerHTML = `<span class="chapter-num">${i + 1}</span><span class="menu-item-label">${truncate(chap.title, 20)}${playing}</span>`;
        el.dataset.index = i;
        list.appendChild(el);
      });
    }

    function buildSettingsView() {
      const list = document.getElementById('settingsList');
      list.innerHTML = '';
      const voiceName = ttsVoice ? ttsVoice.name.replace(/ \(.*\)/, '') : 'None';
      const items = [
        { label: 'Theme', value: settings.theme === 'light' ? 'Classic' : 'Backlit', key: 'theme' },
        { label: 'Voice', value: settings.ttsEnabled ? 'On' : 'Off', key: 'tts' },
        { label: 'Speaker', value: truncate(voiceName, 10), key: 'speaker' },
        { label: 'Default WPM', value: `${settings.defaultWpm}`, key: 'defaultWpm' },
        { label: 'Clear Library', value: '', key: 'clearLibrary' },
      ];
      const sel = menuSelections['settings'] || 0;
      items.forEach((item, i) => {
        const el = document.createElement('div');
        el.className = 'settings-item' + (i === sel ? ' selected' : '');
        el.innerHTML = `<span>${item.label}</span><span class="settings-value">${item.value}</span>`;
        el.dataset.key = item.key;
        el.dataset.index = i;
        list.appendChild(el);
      });
    }

    // =========================================================
    //  MENU NAVIGATION
    // =========================================================
    function getItemCount(view) {
      switch (view) {
        case 'menu': return document.querySelectorAll('#menuList .menu-item').length;
        case 'library': return document.querySelectorAll('#libraryList .menu-item').length;
        case 'chapters': return document.querySelectorAll('#chaptersList .chapter-item').length;
        case 'settings': return document.querySelectorAll('#settingsList .settings-item').length;
        default: return 0;
      }
    }

    function scrollSelection(delta) {
      ensureAudio();
      const view = currentView();
      if (view === 'nowPlaying') {
        adjustSpeed(delta > 0 ? WPM_STEP : -WPM_STEP);
        playClick();
        return;
      }

      const count = getItemCount(view);
      if (count === 0) return;

      let sel = menuSelections[view] || 0;
      const newSel = sel + delta;
      if (newSel < 0 || newSel >= count) return; // don't wrap, don't click
      sel = newSel;
      menuSelections[view] = sel;

      playClick();

      if (view === 'menu') buildMainMenu();
      if (view === 'library') buildLibraryView();
      if (view === 'chapters') buildChaptersView();
      if (view === 'settings') buildSettingsView();
    }

    function selectAction() {
      ensureAudio();
      playSelectSound();
      const view = currentView();

      if (view === 'nowPlaying') { togglePlayPause(); return; }

      if (view === 'menu') {
        const sel = menuSelections['menu'] || 0;
        const items = document.querySelectorAll('#menuList .menu-item');
        if (!items[sel]) return;
        const action = items[sel].dataset.action;
        if (action === 'addPdf') pdfInput.click();
        else navigateTo(action);
        return;
      }

      if (view === 'library') {
        const sel = menuSelections['library'] || 0;
        if (sel < library.length) {
          const item = library[sel];
          if (item.name === pdfFileName && words.length > 0) navigateTo('nowPlaying');
          else navigateTo('nowPlaying');
        }
        return;
      }

      if (view === 'chapters') {
        const sel = menuSelections['chapters'] || 0;
        if (sel < chapters.length) {
          skipToChapter(sel);
          navigateTo('nowPlaying');
        }
        return;
      }

      if (view === 'settings') {
        const sel = menuSelections['settings'] || 0;
        const items = document.querySelectorAll('#settingsList .settings-item');
        if (!items[sel]) return;
        const key = items[sel].dataset.key;

        if (key === 'theme') {
          settings.theme = settings.theme === 'light' ? 'dark' : 'light';
          applyTheme(); saveSettings(); buildSettingsView();
        } else if (key === 'tts') {
          settings.ttsEnabled = !settings.ttsEnabled;
          if (!settings.ttsEnabled) stopTTS();
          saveSettings(); buildSettingsView();
        } else if (key === 'speaker') {
          // Cycle through available English voices
          const voices = speechSynthesis.getVoices().filter(v => v.lang.startsWith('en'));
          if (voices.length > 0) {
            const curIdx = ttsVoice ? voices.findIndex(v => v.name === ttsVoice.name) : -1;
            const nextIdx = (curIdx + 1) % voices.length;
            ttsVoice = voices[nextIdx];
            settings.voice = ttsVoice.name;
            saveSettings(); buildSettingsView();
          }
        } else if (key === 'defaultWpm') {
          settings.defaultWpm += 50;
          if (settings.defaultWpm > MAX_WPM) settings.defaultWpm = MIN_WPM;
          wpm = settings.defaultWpm;
          saveSettings(); buildSettingsView();
        } else if (key === 'clearLibrary') {
          library = []; bookmarks = {};
          saveSettings(); buildLibraryView(); buildSettingsView();
        }
        return;
      }
    }

    // =========================================================
    //  CLICK WHEEL CONTROLS
    // =========================================================
    function setupClickWheel() {
      btnCenter.addEventListener('click', e => { e.stopPropagation(); selectAction(); });

      btnPlayPause.addEventListener('click', e => {
        e.stopPropagation();
        ensureAudio();
        playSelectSound();
        if (currentView() === 'nowPlaying') togglePlayPause();
        else { navigateTo('nowPlaying'); if (words.length > 0) togglePlayPause(); }
      });

      btnMenu.addEventListener('click', e => { e.stopPropagation(); goBack(); });

      btnForward.addEventListener('click', e => {
        e.stopPropagation();
        ensureAudio();
        playClick();
        if (currentView() === 'nowPlaying') skipForward();
        else scrollSelection(1);
      });

      btnBack.addEventListener('click', e => {
        e.stopPropagation();
        ensureAudio();
        playClick();
        if (currentView() === 'nowPlaying') skipBack();
        else scrollSelection(-1);
      });

      // Hold-to-repeat
      let holdInterval = null;
      function startHold(action) { action(); holdInterval = setInterval(action, 120); }
      function stopHold() { if (holdInterval) { clearInterval(holdInterval); holdInterval = null; } }

      btnForward.addEventListener('mousedown', e => { e.stopPropagation(); if (currentView() === 'nowPlaying') startHold(() => { playClick(); skipForward(); }); });
      btnBack.addEventListener('mousedown', e => { e.stopPropagation(); if (currentView() === 'nowPlaying') startHold(() => { playClick(); skipBack(); }); });
      document.addEventListener('mouseup', stopHold);

      btnForward.addEventListener('touchstart', e => { e.preventDefault(); e.stopPropagation(); if (currentView() === 'nowPlaying') startHold(() => { playClick(); skipForward(); }); });
      btnBack.addEventListener('touchstart', e => { e.preventDefault(); e.stopPropagation(); if (currentView() === 'nowPlaying') startHold(() => { playClick(); skipBack(); }); });
      document.addEventListener('touchend', stopHold);
    }

    // --- Wheel Rotation ---
    function setupWheelGesture() {
      let isDragging = false;
      let lastAngle = null;
      let accumulated = 0;

      function getAngle(e) {
        const rect = clickWheel.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return Math.atan2(clientY - cy, clientX - cx);
      }

      function isOnRing(e) {
        const rect = clickWheel.getBoundingClientRect();
        const cx = rect.width / 2, cy = rect.height / 2;
        const clientX = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
        const clientY = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
        const dist = Math.hypot(clientX - cx, clientY - cy);
        return dist > 35 && dist <= rect.width / 2;
      }

      clickWheel.addEventListener('mousedown', e => {
        if (e.target === clickWheel && isOnRing(e)) {
          ensureAudio();
          isDragging = true; lastAngle = getAngle(e); accumulated = 0;
        }
      });
      clickWheel.addEventListener('touchstart', e => {
        if (e.target === clickWheel && isOnRing(e)) {
          ensureAudio();
          isDragging = true; lastAngle = getAngle(e); accumulated = 0;
        }
      });

      document.addEventListener('mousemove', e => { if (isDragging) handleRotation(e); });
      document.addEventListener('touchmove', e => { if (isDragging) handleRotation(e); });

      function handleRotation(e) {
        const currentAngle = getAngle(e);
        if (lastAngle === null) { lastAngle = currentAngle; return; }
        let delta = currentAngle - lastAngle;
        if (delta > Math.PI) delta -= 2 * Math.PI;
        if (delta < -Math.PI) delta += 2 * Math.PI;
        accumulated += delta;
        lastAngle = currentAngle;

        const threshold = 0.26;
        if (Math.abs(accumulated) >= threshold) {
          const steps = Math.floor(Math.abs(accumulated) / threshold);
          const dir = accumulated > 0 ? 1 : -1;
          if (currentView() === 'nowPlaying') {
            adjustSpeed(dir * WPM_STEP * steps);
            playClick();
          } else {
            for (let i = 0; i < steps; i++) scrollSelection(dir);
          }
          accumulated = accumulated % threshold;
        }
      }

      document.addEventListener('mouseup', () => { isDragging = false; lastAngle = null; });
      document.addEventListener('touchend', () => { isDragging = false; lastAngle = null; });
    }

    // --- Keyboard ---
    function setupKeyboard() {
      document.addEventListener('keydown', e => {
        ensureAudio();
        switch (e.code) {
          case 'Space':
            e.preventDefault();
            if (currentView() === 'nowPlaying') { playSelectSound(); togglePlayPause(); }
            else selectAction();
            break;
          case 'ArrowRight':
            e.preventDefault();
            playClick();
            if (currentView() === 'nowPlaying') skipForward();
            else scrollSelection(1);
            break;
          case 'ArrowLeft':
            e.preventDefault();
            playClick();
            if (currentView() === 'nowPlaying') skipBack();
            else scrollSelection(-1);
            break;
          case 'ArrowUp':
            e.preventDefault();
            if (currentView() === 'nowPlaying') { playClick(); adjustSpeed(WPM_STEP); }
            else scrollSelection(-1);
            break;
          case 'ArrowDown':
            e.preventDefault();
            if (currentView() === 'nowPlaying') { playClick(); adjustSpeed(-WPM_STEP); }
            else scrollSelection(1);
            break;
          case 'Enter':
            e.preventDefault();
            selectAction();
            break;
          case 'Escape':
          case 'Backspace':
            e.preventDefault();
            goBack();
            break;
        }
      });
    }

    // =========================================================
    //  INIT
    // =========================================================
    loadSettings();
    setupTTS();
    setupEQ();
    setupDragAndDrop();
    setupClickWheel();
    setupWheelGesture();
    setupKeyboard();
    buildMainMenu();
    runBootSequence();
  </script>
</body>
</html>
